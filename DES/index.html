<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Spread Simulation with Canvas</title>
</head>
<body>

<h1>Fire Spread Simulation</h1>
<canvas id="canvas" width="300" height="300"></canvas>

<script>
    class Logger {
        static log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
    }

    class Event {
        constructor(time) {
            this.time = time;
        }
        execute() {
            throw new Error("Execute method should be implemented in subclasses");
        }
    }

    class FireSpreadEvent extends Event {
        constructor(time, grid, renderer, x, y) {
            super(time);
            this.grid = grid;
            this.renderer = renderer;
            this.x = x;
            this.y = y;
        }

        execute() {
            Logger.log(`Executing FireSpreadEvent at (${this.x}, ${this.y}) on ${this.time}`);
            const cell = this.grid.getCell(this.x, this.y);
            if (cell.status === "unburned") {
                cell.status = "burning";
                this.renderer.render(this.grid);

                // Schedule fire spread to neighboring cells
                const neighbors = this.grid.getNeighbors(this.x, this.y);
                for (let neighbor of neighbors) {
                    if (neighbor.status === "unburned" && Math.random() > 0.3) {
                        this.grid.addEvent(new FireSpreadEvent(this.time + 1, this.grid, this.renderer, neighbor.x, neighbor.y));
                    }
                }

                // Schedule the cell to burn out
                this.grid.addEvent(new BurnOutEvent(this.time + 2, this.grid, this.renderer, this.x, this.y));
            }
        }
    }

    class BurnOutEvent extends Event {
        constructor(time, grid, renderer, x, y) {
            super(time);
            this.grid = grid;
            this.renderer = renderer;
            this.x = x;
            this.y = y;
        }

        execute() {
            Logger.log(`Executing BurnOutEvent at (${this.x}, ${this.y})`);
            const cell = this.grid.getCell(this.x, this.y);
            cell.status = "burned";
            this.renderer.render(this.grid);
        }
    }

    class EventQueue {
        constructor() {
            this.queue = [];
        }

        addEvent(event) {
            this.queue.push(event);
            this.queue.sort((a, b) => a.time - b.time);
        }

        getNextEvent() {
            return this.queue.shift();
        }

        isEmpty() {
            return this.queue.length === 0;
        }
    }

    class Cell {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.status = "unburned"; // possible values: "unburned", "burning", "burned"
        }
    }

    class Grid {
        constructor(size) {
            this.size = size;
            this.cells = Array.from({ length: size }, (_, y) =>
                Array.from({ length: size }, (_, x) => new Cell(x, y))
            );
            this.eventQueue = new EventQueue();
        }

        getCell(x, y) {
            return this.cells[y] && this.cells[y][x];
        }

        getNeighbors(x, y) {
            return [
                this.getCell(x + 1, y),
                this.getCell(x - 1, y),
                this.getCell(x, y + 1),
                this.getCell(x, y - 1),

                this.getCell(x + 1, y + 1),
                this.getCell(x - 1, y - 1),
                this.getCell(x + 1, y - 1),
                this.getCell(x - 1, y + 1)
            ].filter(cell => cell !== undefined);
        }

        addEvent(event) {
            this.eventQueue.addEvent(event);
        }

        step() {
            if (!this.eventQueue.isEmpty()) {
                const event = this.eventQueue.getNextEvent();
                event.execute();
            }
        }
    }

    class Renderer {
        constructor(canvas, cellSize) {
            this.canvas = canvas;
            this.context = canvas.getContext("2d");
            this.cellSize = cellSize;
        }

        render(grid) {
            const ctx = this.context;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            for (let y = 0; y < grid.size; y++) {
                for (let x = 0; x < grid.size; x++) {
                    const cell = grid.getCell(x, y);
                    ctx.fillStyle = this.getColor(cell.status);
                    ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                }
            }
        }

        getColor(status) {
            switch (status) {
                case "unburned": return "#9acd32";  // green
                case "burning": return "#ff4500";   // red
                case "burned": return "#555";       // gray
                default: return "#ffffff";          // white
            }
        }
    }

    // Initialize canvas and grid
    const canvas = document.getElementById("canvas");
    const gridSize = 10;
    const cellSize = 30;
    const renderer = new Renderer(canvas, cellSize);
    const grid = new Grid(gridSize);
    renderer.render(grid);

    // Add initial fire event at the center
    grid.addEvent(new FireSpreadEvent(0, grid, renderer, Math.floor(gridSize / 2), Math.floor(gridSize / 2)));

    function runSimulation() {
        grid.step();
        if (!grid.eventQueue.isEmpty()) {
            setTimeout(runSimulation, 500);
        }
    }

    runSimulation();
</script>

</body>
</html>
